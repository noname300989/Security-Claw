#!/usr/bin/env python3
"""
Browser Extension Pentest â€” Report Generator
Produces a detailed Markdown report with all findings, PoC payloads, screenshots, and remediation.
"""

import json
import sys
from pathlib import Path
from datetime import datetime, timezone


SEV_EMOJI = {"CRITICAL": "ğŸ”´", "HIGH": "ğŸŸ ", "MEDIUM": "ğŸŸ¡", "LOW": "ğŸ”µ", "INFO": "âšª"}
SEV_ORDER = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4}


def generate(
    findings: list[dict],
    ext_name: str = "Unknown Extension",
    ext_version: str = "?",
    target_path: str = "N/A",
    output_file: str = "ext_pentest_report.md"
) -> str:
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    findings_sorted = sorted(findings, key=lambda x: SEV_ORDER.get(x.get("severity", "INFO"), 4))

    confirmed = [f for f in findings_sorted if f.get("confirmed", False)]
    by_severity = {}
    for f in findings_sorted:
        s = f.get("severity", "INFO")
        by_severity[s] = by_severity.get(s, 0) + 1

    # â”€â”€ Executive Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    report = f"""# ğŸ§© Browser Extension Penetration Test Report

---

## Executive Summary

| Field | Value |
|---|---|
| **Target Extension** | {ext_name} v{ext_version} |
| **Extension Path** | `{target_path}` |
| **Assessment Date** | {now} |
| **Total Findings** | {len(findings_sorted)} |
| **Confirmed Exploitable** | {len(confirmed)} |
| **Critical** | {by_severity.get('CRITICAL', 0)} |
| **High** | {by_severity.get('HIGH', 0)} |
| **Medium** | {by_severity.get('MEDIUM', 0)} |
| **Low** | {by_severity.get('LOW', 0)} |
| **Info** | {by_severity.get('INFO', 0)} |

"""

    # Risk matrix
    if by_severity.get("CRITICAL", 0) > 0:
        report += "> ğŸš¨ **CRITICAL RISK**: Extension has confirmed critical vulnerabilities. DO NOT deploy or distribute.\n\n"
    elif by_severity.get("HIGH", 0) > 0:
        report += "> âš ï¸ **HIGH RISK**: High-severity exploitable vulnerabilities found. Immediate remediation required.\n\n"
    elif by_severity.get("MEDIUM", 0) > 0:
        report += "> ğŸ”¶ **MEDIUM RISK**: Moderate security issues found. Remediation recommended before release.\n\n"
    else:
        report += "> âœ… **LOW RISK**: No critical or high severity issues. Minor issues detected.\n\n"

    report += "---\n\n## Attack Surface Summary\n\n"
    categories = list(dict.fromkeys(f.get("category", "Other") for f in findings_sorted))
    for cat in categories:
        cat_findings = [f for f in findings_sorted if f.get("category") == cat]
        report += f"- **{cat}**: {len(cat_findings)} finding(s)\n"

    report += "\n---\n\n## Detailed Findings\n\n"

    # â”€â”€ Individual Findings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for idx, f in enumerate(findings_sorted, 1):
        sev = f.get("severity", "INFO")
        emoji = SEV_EMOJI.get(sev, "âšª")
        confirmed_badge = "âœ… **CONFIRMED EXPLOITED**" if f.get("confirmed") else "âš ï¸ Potential"

        report += f"### Finding #{idx}: {emoji} {f.get('title', 'Unknown')}\n\n"
        report += f"| Field | Value |\n|---|---|\n"
        report += f"| **Severity** | {sev} |\n"
        report += f"| **Status** | {confirmed_badge} |\n"
        report += f"| **Category** | {f.get('category', 'N/A')} |\n"
        report += f"| **OWASP** | {f.get('owasp', 'N/A')} |\n"
        report += f"| **CVSS Score** | {f.get('cvss', 'N/A')} |\n"
        report += f"| **CWE** | [{f.get('cwe', 'N/A')}](https://cwe.mitre.org/data/definitions/{f.get('cwe','').replace('CWE-','')}.html) |\n\n"

        report += f"**Description:** {f.get('description', '')}\n\n"

        # PoC Payload
        poc = f.get("poc_payload") or f.get("poc", "")
        if poc:
            report += f"**Proof-of-Concept Payload:**\n```\n{poc}\n```\n\n"

        # Exploit Steps
        steps = f.get("exploit_steps", [])
        if steps:
            report += "**Step-by-Step Exploitation:**\n"
            for step in steps:
                report += f"{step}\n"
            report += "\n"

        # Source Locations
        locations = f.get("source_locations", [])
        if locations:
            report += "**Vulnerable Source Locations:**\n"
            for loc in locations:
                report += f"- `{loc}`\n"
            report += "\n"

        # Screenshot Evidence
        shot = f.get("evidence_screenshot")
        if shot and Path(shot).exists():
            rel = Path(shot).name
            report += f"**Screenshot Evidence:**\n\n![{f.get('title', 'Evidence')}]({shot})\n\n"

        # Responses / captured data
        responses = f.get("responses_captured", [])
        if responses:
            report += "**Captured Message Responses:**\n```json\n"
            report += json.dumps(responses, indent=2)
            report += "\n```\n\n"

        report += f"**Remediation:** {f.get('remediation', 'Review and patch.')}\n\n"
        report += "---\n\n"

    # â”€â”€ Appendix: Full Findings JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    report += "## Appendix: Machine-Readable Findings\n\n"
    report += "```json\n"
    report += json.dumps(findings_sorted, indent=2)
    report += "\n```\n"

    Path(output_file).write_text(report, encoding="utf-8")

    # Also save findings.json
    json_out = Path(output_file).with_suffix(".json")
    json_out.write_text(json.dumps({"findings": findings_sorted, "summary": by_severity}, indent=2))

    return output_file


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("findings_json", help="Path to findings JSON file")
    parser.add_argument("--output", default="ext_pentest_report.md")
    parser.add_argument("--ext-name", default="Unknown")
    parser.add_argument("--ext-version", default="?")
    args = parser.parse_args()
    findings = json.loads(Path(args.findings_json).read_text())
    if isinstance(findings, dict):
        findings = findings.get("findings", findings)
    out = generate(findings, args.ext_name, args.ext_version, output_file=args.output)
    print(json.dumps({"report": out}))
